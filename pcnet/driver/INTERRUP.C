/*++

Copyright (c) 1996 ADVANCED MICRO DEVICES, INC. All Rights Reserved.
This software is unpblished and contains the trade secrets and
confidential proprietary information of AMD. Unless otherwise provided
in the Software Agreement associated herewith, it is licensed in confidence
"AS IS" and is not to be reproduced in whole or part by any means except
for backup. Use, duplication, or disclosure by the Government is subject
to the restrictions in paragraph (b) (3) (B) of the Rights in Technical
Data and Computer Software clause in DFAR 52.227-7013 (a) (Oct 1988).
Software owned by Advanced Micro Devices, Inc., 901 Thompson Place,
Sunnyvale, CA 94088.

Module Name:

	interrup.c

Abstract:

	This file contains the interrupt handling routines.

Environment:

	Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

	$Log:   V:\network\pcnet\mini3&4\src\interrup.c_v  $
 *
 *    Rev 1.56   02 Oct 1997 12:34:46   steiger
 * Changed status field in rx'd packet OOB data
 * from NDIS_STATUS_PENDING to NDIS_STATUS_RESOURCES.
 * This prevents protocols from retaining ownership
 * of a packet after the call to NdisMIndicateReceivePacket.
 *
 *
 *    Rev 1.55   30 Sep 1997 15:28:22   steiger
 * Added code to preserve the RAP register contents. Was causing data corruption when I/O macros were preempted because of LanceISR.
 *
 *
 *    Rev 1.55   30 Sep 1997 15:17:20   steiger
 *
 *
 *
 *    Rev 1.54   02 Sep 1997 13:58:42   steiger
 * Modified LanceHandleInterrupt () so that the OWN bit is set immediately if the received packet
 * has an error and will not be placed in the packet array for the subsequent call to NdisMIndicateReceivePacket.
 * Also changed LanceHandleInterrupt () so that it no longer writes the address of LanceRMDFlags to the MiniportReserved
 * field of the NDIS packet descriptor; instead it is done during LanceSetupRegistersAndInit () in LANCE.C.
 *
 *
 *    Rev 1.53   20 Aug 1997 14:23:48   steiger
 * Further refinements to multi-send and multi-receive.
 *
 *
 *    Rev 1.52   12 Aug 1997 17:50:58   steiger
 * Multi-RX implemented. Copy/Compare testing has been done.

--*/

#include <ndis.h>
#include <efilter.h>
#include <lancehrd.h>
#include <lancesft.h>

#ifdef	NDIS40_MINIPORT

STATIC
VOID
XmitComplete (
	IN PLANCE_ADAPTER Adapter
	);

STATIC
VOID
RcvComplete (
	PNDIS_PACKET			*PktArray,
	PNDIS_BUFFER			*BufArray,
	USHORT					PktIndex
	);

#endif	/* NDIS40_MINIPORT */

VOID
LanceEnableInterrupt(
	IN NDIS_HANDLE Adapter
	)

/*++

Routine Description:

	This routine enables interrupts on the adapter.

Arguments:

	Adapter - Pointer to the adapter structure.

Return Value:

	None.

--*/

{
	ULONG SavedRAPValue;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceEnableInterrupt : %i\n",((PLANCE_ADAPTER)Adapter)->RedundantMode);
	#endif
	
	/* Enable device interrupts	*/
	ASIC_ENABLE_INTERRUPTS(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress);
	LANCE_WRITE_CSR(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress, LANCE_CSR0, LANCE_CSR0_IENA);
	
	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceEnableInterrupt\n");
	#endif

}

VOID
LanceDisableInterrupt(
	IN NDIS_HANDLE Adapter
	)

/*++

Routine Description:

	This routine disables interrupts on the adapter.

Arguments:

	Adapter - Pointer to the adapter structure.

Return Value:

	None.

--*/

{
	ULONG SavedRAPValue;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceDisableInterrupt : %i\n",((PLANCE_ADAPTER)Adapter)->RedundantMode);
	#endif

	/* Save RAP value */
	//NdisRawReadPortUshort(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + LANCE_RAP_PORT, &SavedRAPValue);		
	//NdisRawWritePortUlong((((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + ASIC_IO_ADDRESS_REGISTER), ((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + ASIC_IO_OFFSET + LANCE_DWIO_RAP_PORT); 	
    //NdisRawReadPortUlong((((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + ASIC_IO_DATA_REGISTER), &SavedRAPValue); 

	/* Disable device interrupts.	Only IENA is affected by writing 0	*/
	ASIC_DISABLE_INTERRUPTS(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress);
	LANCE_WRITE_CSR(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress, LANCE_CSR0, 0);

	/* Restore RAP value */	
	//NdisRawWritePortUshort(((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + LANCE_RAP_PORT, SavedRAPValue);
	//NdisRawWritePortUlong((((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + ASIC_IO_ADDRESS_REGISTER), ((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + ASIC_IO_OFFSET + LANCE_DWIO_RAP_PORT); 	
    //NdisRawWritePortUlong((((PLANCE_ADAPTER)Adapter)->MappedIoBaseAddress + ASIC_IO_DATA_REGISTER), SavedRAPValue); 

	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceDisableInterrupt\n");
	#endif
}

VOID
LanceISR(
	OUT PBOOLEAN InterruptRecognized,
	OUT PBOOLEAN QueueDpc,
	IN PVOID Context
	)

/*++

Routine Description:

	Interrupt service routine. Determines whether or not the interrupt was
	generated by our hardware, and if so, clears the source of the interrupt
	and queues a DPC (Deferred Procedure Call).

Arguments:

	InterruptRecongnized	Pointer to variable that is set by this routine.
							It is set TRUE if interrupt is ours, else FALSE.

	QueueDpc			 	TRUE if a DPC is queued. Only valid if
							InterruptRecognized is TRUE.

	Context					Essentially, a pointer to the adapter data
							structure.

Return Value:

	None

--*/

{

	PLANCE_ADAPTER	Adapter = Context;
	ULONG			Csr0Value;
	ULONG			SavedRAPValue;
	USHORT ASICData18, ASICData02;

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceISR\n");
	#endif

	LOG(IN_ISR)

	/* Read ASIC interrupt flags?
       ASIC is not documented. */
	NdisRawReadPortUshort((Adapter->MappedIoBaseAddress + 0x18), &ASICData18);
	NdisRawReadPortUshort((Adapter->MappedIoBaseAddress + 0x02), &ASICData02);

	/* Set default return value	*/
	*InterruptRecognized = FALSE;

	/* Check reset flag. If the flag is set, we don't	*/
	/* own this interrupt	*/
	if (Adapter->OpFlags & RESET_IN_PROGRESS)
	{
  		#if DBG
		if (LanceDbg)
			DbgPrint("LanceISR: ABORT: Reset in Progress.\n");
		#endif
		return;
	}

	/* Save RAP value */
	////NdisRawReadPortUshort(Adapter->MappedIoBaseAddress + LANCE_RAP_PORT, &SavedRAPValue);
	//****This is not used in the Phoenix code
	//NdisRawWritePortUlong((Adapter->MappedIoBaseAddress + ASIC_IO_ADDRESS_REGISTER), (Adapter->MappedIoBaseAddress + ASIC_IO_OFFSET + LANCE_DWIO_RAP_PORT)); 	
    //NdisRawReadPortUlong((Adapter->MappedIoBaseAddress + ASIC_IO_DATA_REGISTER), &SavedRAPValue);   

	/* Read CSR0 value	*/
	LANCE_READ_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, &Csr0Value);

	/* Check if we own this interrupt	*/	
	if ((Csr0Value & (LANCE_CSR0_INTR)) && (Csr0Value & (LANCE_CSR0_IENA)) )
	{
		/* Disable interrupt source. Writing zeroes to the interrupt status */
		/* bits in CSR0 has no effect on them. All the other bits except	*/
		/* IENA (interrupt enable, bit 6) are read only.					*/
		LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, 0);

		/* Replace default return value	*/
		*InterruptRecognized = TRUE;

/* According to the NDIS 4.0 spec, *QueueDpc is set TRUE whenever a DPC is	*/
/* required to complete interrupt processing. Should always be TRUE			*/
/* whenever *InterruptRecognized is TRUE. I am unable to determine why it	*/
/* was originally coded as having anything to do with the interrupt signal	*/
/* type. (As in the original line commented out below)						*/

//		*QueueDpc = (Adapter->InterruptMode == NdisInterruptLevelSensitive);
		*QueueDpc = TRUE;

		/* Set interrupt flag	*/
		Adapter->OpFlags |= IN_INTERRUPT_DPC;	
	}
	else
	{
		#if DBG
		if (LanceDbg)
			DbgPrint("IDON bit = %x\n",Csr0Value);
			DbgPrint("LanceISR routine: Not my interrupt.\n");
		#endif
	}

    /* Acknowledge ASIC interrupt flags and re-prepare?
	   ASIC is not documented. */
	NdisRawWritePortUshort((Adapter->MappedIoBaseAddress + 0x18), ASICData18);
	NdisRawWritePortUshort((Adapter->MappedIoBaseAddress + 0x02), ASICData02);
	NdisRawWritePortUshort((Adapter->MappedIoBaseAddress + 0x1A), 0x0FFF);

	LOG(OUT_ISR)

	/* Restore RAP value */
	//NdisRawWritePortUshort(Adapter->MappedIoBaseAddress + LANCE_DWIO_RAP_PORT, SavedRAPValue);
	//***Not use in Phoenix code
	//NdisRawWritePortUlong((Adapter->MappedIoBaseAddress + ASIC_IO_ADDRESS_REGISTER), (Adapter->MappedIoBaseAddress + ASIC_IO_OFFSET + LANCE_DWIO_RAP_PORT)); 	
    //NdisRawWritePortUlong((Adapter->MappedIoBaseAddress + ASIC_IO_DATA_REGISTER), SavedRAPValue); 		
   
	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceISR\n");
	#endif
}


VOID
LanceHandleInterrupt(
	IN PVOID Context
	)

/*++

Routine Description:

	This routine is queued by the interrupt service routine
	when deferred processing needs to be done, i.e. packet transmit
	completion, packet reception, etc.

Arguments:

	Context - A pointer to the adapter data structure.

Return Value:

	None.

--*/

{
	USHORT *		CurrBufferSize;
	USHORT *		CurrByteCount;
	UCHAR *			CurrRMDReserved1;
	UCHAR *			CurrRMDFlags;
	ULONG		    Csr0Value;
	UCHAR			DummyUchar;
	/* Receive status of the packet.	*/
	UCHAR ReceiveStatus;

	PLANCE_ADAPTER Adapter = (PLANCE_ADAPTER)Context;

	/* Pointer to the receive descriptor being examined.	*/
	PLANCE_RECEIVE_DESCRIPTOR CurrentDescriptor;

	/* Pointer to the receive descriptor being examined.	*/
	PLANCE_RECEIVE_DESCRIPTOR_HI CurrentDescriptorHi;

	/* Receive buffer address	*/
	NDIS_PHYSICAL_ADDRESS CurrentBufferPhysical;

	/* The virtual address of the packet.	*/
	PVOID PacketVa;

	/* Look adead packet size for indication	*/
	UINT LookAheadSize;

	/* The size of the packet.	*/
	UINT PacketSize;

	/* Index to descriptor to be processed.	*/
	USHORT CurrentDescriptorIndex;

	BOOLEAN IndicatingPacket = FALSE;
	BOOLEAN IndicateRxComplete = FALSE;

	NDIS_BUFFER Buffer;

	UINT	Data = 0;
	USHORT Time = 0;
	/* Receive packet type.	*/
	USHORT ReceivePacketType;

	ULONGLONG	SystemTime;
	
	USHORT BufferSize;


#ifdef NDIS40_MINIPORT

	PNDIS_PACKET *			PktArray = Adapter->PktArray;
	PNDIS_BUFFER *			BufArray = Adapter->BufArray;
	USHORT					PktIndex = 0;
	PNDIS_PACKET_OOB_DATA	OobPktData;
	BOOLEAN					IsCancelled;
//	UINT phyCnt,bufCnt,length;

#endif

	#if DBG
		if (LanceDbg)
		DbgPrint("==>LanceHandleInterrupt : %i\n",Adapter->RedundantMode);
	#endif

	LOG(IN_DPC)

#ifdef _FAILOVER
	if ((Adapter->RedundantMode == 2) && (ActiveAdapter == PRI))
		return;
#endif

	/* Check reset flag. If the flag is set, we don't	*/
	/* own this interrupt	*/
	if (Adapter->OpFlags & RESET_IN_PROGRESS)
	{
		#if DBG
		if (LanceDbg)
			DbgPrint("LanceHandleInterrupt: ABORT: Reset in Progress.\n");
		#endif
		return;

	}

	/* Read CSR0 for interrupts	*/
	LANCE_READ_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, &Csr0Value);

	/* Check if there are any pending interrupts	*/
	/* If STOP bit is set, reset the chip.	Note: when	*/
	/* chip stops, all chip interrupts are disabled	*/
	if (Adapter->OpFlags & STOP_SET || Csr0Value & LANCE_CSR0_STOP)
	{
		#if DBG
		if (LanceDbg)
		{
			DbgPrint("LanceHandleInterrupt: STOP bit set on Rx. Reset sequence initiated. \n");
		}
		#endif

		Adapter->OpFlags |= STOP_SET;

		/* Restart chip	*/
		LanceInit(Adapter,FALSE);

//		Adapter->OpFlags |= RESET_IN_PROGRESS;

//		if(Adapter->OpFlags & IN_LINK_TIMER)
//		{
//			NdisStallExecution(1);
//		}

//		LanceStopChip(Adapter);

//		LanceSetupRegistersAndInit(Adapter,FALSE);

		/* Start Lance, but do not enable interrupts as	*/
		/* interrupts will be enabled at the end of DPC.	*/
		/*LANCE_WRITE_PORT(Adapter, LANCE_CSR0, LANCE_CSR0_START); */

		/* Clear the flags and return	*/
//		Adapter->OpFlags &= ~RESET_IN_PROGRESS;
		Adapter->OpFlags &= ~IN_INTERRUPT_DPC;
		Adapter->OpFlags &= ~STOP_SET;
		return;

	}

	if ((Csr0Value & LANCE_CSR0_MISS) &&
		(Adapter->DeviceType == PCNET_ISA) &&
		(Adapter->DeviceRevisionId != PCNET_ISA_B2_REV_ID))
	{
		#if DBG
		if(LanceDbg)
		{
			DbgPrint("CSR0_MISS on Rx: Reset sequence initiated. \n");
		}
		#endif

		if(!(Adapter->OpFlags & RESET_IN_PROGRESS))
		{
			Adapter->OpFlags &= ~(STOP_SET);
		}
	}	

	/* Check for receive interrupts.	*/
	if (Csr0Value & (LANCE_CSR0_RINT | LANCE_CSR0_MISS))
	{		
		/* Handle receive interrupt	*/		
		
		/* IndicatingReceiving = LanceProcessReceiveInterrupts(Adapter);	*/
		/* We don't get here unless there was a receive. Loop through		*/
		/* the receive descriptors starting at the last known descriptor	*/
		/* owned by the hardware that begins a packet and examine each 		*/
		/* receive ring descriptor for errors.								*/

		#if DBG
		if (LanceRxDbg)
			DbgPrint("Enter LanceReceiveInterrupt Loop.\n");
		#endif

		LOG(RECEIVE)

//		NdisGetCurrentSystemTime(&SystemTime);

		while (TRUE) /* One loop traversal per received packet */
		{
			/* Point to current receive descriptor	*/
			CurrentDescriptorIndex = Adapter->NextReceiveDescriptorIndex;

			/* Since the structure template differs based on SwStyle & 	*/
			/* certain structure members are read/mod/written			*/
			/* multiple times for each received packet, we will get		*/
			/* pointers to the relevant members and thus avoid having	*/
			/* to test Adapter->SwStyle more than once each time we		*/
			/* need to access the current descriptor.					*/

			if (Adapter->SwStyle == SW_STYLE_2)
			{
				CurrentDescriptorHi	= (PLANCE_RECEIVE_DESCRIPTOR_HI)Adapter->ReceiveDescriptorRing +
									CurrentDescriptorIndex;
				ReceiveStatus 		= CurrentDescriptorHi->LanceRMDFlags;
				CurrBufferSize		= &(CurrentDescriptorHi->BufferSize);
				CurrByteCount 		= &(CurrentDescriptorHi->ByteCount);
				CurrRMDReserved1	= &(CurrentDescriptorHi->LanceRMDReserved1);
				CurrRMDFlags		= &(CurrentDescriptorHi->LanceRMDFlags);
			}
			else	/* SW_STYLE_0 */
			{
				CurrentDescriptor	= (PLANCE_RECEIVE_DESCRIPTOR)Adapter->ReceiveDescriptorRing +
									CurrentDescriptorIndex;
				ReceiveStatus		= CurrentDescriptor->LanceRMDFlags;
				CurrBufferSize		= &(CurrentDescriptor->BufferSize);
				CurrByteCount		= &(CurrentDescriptor->ByteCount);
				/* LanceRMDReserved1 doesn't exist in SW style 0, so point	*/
				/* it at a benign variable so the pointer is valid			*/
				CurrRMDReserved1	= &DummyUchar;
				CurrRMDFlags		= &(CurrentDescriptor->LanceRMDFlags);
			}

			if (ReceiveStatus & LANCE_RECEIVE_BUFFER_ERROR)
				++Adapter->DmiSpecific[DMI_RXBUFF_ERR];

			if (ReceiveStatus & OWN)
			{
				#if DBG
				if(LanceRxDbg && (!IndicatingPacket))
					/* No descriptors belonging to us were found */
					DbgPrint("LanceReceiveInterrupt: No rx descriptors to process.\n");
				#endif
				/* Clear interrupt source #2 */
				LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, (LANCE_CSR0_RINT | LANCE_CSR0_MISS));
				/* Check status after clearing int */
				if (ReceiveStatus & OWN)
					break;	/* The only way out of this 'while' loop */
			}
			if (PktIndex >= RX_INT_WATERMARK)
			{
				NdisMIndicateReceivePacket(Adapter->LanceMiniportHandle, PktArray, PktIndex);
				RcvComplete (PktArray, BufArray, PktIndex);
				PktIndex = 0;
				IndicatingPacket = FALSE;
				IndicateRxComplete = TRUE;
			}


			/* If we've made it to here, there must be at least one	*/
			/* descriptor to process ...							*/

			/* Check that the packet was received correctly.	*/
			/* As we have the buffer which can receive maximum size packet,	*/
			/* ENP and STP should be set.	*/
			if ((ReceiveStatus & DERR) ||
			  !((ReceiveStatus & ENP) && (ReceiveStatus & STP)))
			{

				#if DBG
					if (LanceRxDbg)
						DbgPrint("LanceReceiveInterrupt: Skipping this descriptor. Rx status = %lx\n", ReceiveStatus);
				#endif
#ifdef NDIS40_MINIPORT
				*CurrRMDFlags = OWN;
#endif
				goto SkipIndication;	/* *YUK* */

			}

			/* Check if packet size is valid	*/
			PacketSize = *CurrByteCount - 4;

			if (PacketSize > LANCE_INDICATE_MAXIMUM)
			{
				#if DBG
					DbgPrint("LanceReceiveInterrupt: Packet too large, length %d\n", PacketSize);
				#endif

#ifdef NDIS40_MINIPORT
				*CurrRMDFlags = OWN;
#endif
				goto SkipIndication;	/* *YUK* */
			}
/*
	MJ modified to check Multi-Rx.
*/
#ifndef NDIS40_MINIPORT
			LookAheadSize = PacketSize;
#endif
			PacketVa = (PVOID)(Adapter->ReceiveBufferPointer +
							(CurrentDescriptorIndex * RECEIVE_BUFFER_SIZE));

			Adapter->DmiSpecific[DMI_RX_BYTES] += (COUNTER64) PacketSize;

			/* Broadcast / multicast?	*/

			if (ETH_IS_MULTICAST(PacketVa))
			{
#if DBG
				if (ETH_IS_BROADCAST(PacketVa))
					ReceivePacketType = LANCE_BROADCAST;
				else
					ReceivePacketType = LANCE_MULTICAST;
#else
				ReceivePacketType = (ETH_IS_BROADCAST(PacketVa)) ?
									LANCE_BROADCAST : LANCE_MULTICAST;
#endif
			}
			else
			{
				ReceivePacketType = LANCE_DIRECTED;
			}
/*
	MJ modified to check Multi-Rx.
*/
#ifdef NDIS40_MINIPORT

		/* [Insert multi-rx code here.] */

		/* 1. Call NdisAdjustBufferLength () to match the size of the buffer with */
		/*    the size of the packet. */

			NdisAdjustBufferLength (Adapter->pNdisBuffer[CurrentDescriptorIndex], PacketSize);

		/* 2. Call NDIS_OOB_DATA_FROM_PACKET to get ptr to the OOB data */
			OobPktData = NDIS_OOB_DATA_FROM_PACKET(Adapter->pNdisPacket[CurrentDescriptorIndex]);

		/* 3. Set OOB status to NDIS_STATUS_RESOURCES to retain ownership of the */
		/*    descriptor */
			OobPktData->Status = NDIS_STATUS_RESOURCES;
//			OobPktData->Status = NDIS_STATUS_SUCCESS;

//			NDIS_SET_PACKET_TIME_RECEIVED(Adapter->pNdisPacket[CurrentDescriptorIndex],SystemTime);

		/* 4. Call NdisFlushBuffer and NdisMUpdateSharedMemory to ensure data */
		/*    integrity. UPDATE: Both calls map to NULL in NDIS.H */
			NdisFlushBuffer (Adapter->pNdisBuffer[CurrentDescriptorIndex], FALSE);
			NdisMUpdateSharedMemory (Adapter->LanceMiniportHandle,
									PacketSize,
									PacketVa,
									Adapter->ReceiveBufferPointerPhysical +
									(CurrentDescriptorIndex	* RECEIVE_BUFFER_SIZE)
									);

		/* 5. Place packet pointer into the packet array & increment the packet array index. */
			BufArray[PktIndex] = Adapter->pNdisBuffer[CurrentDescriptorIndex];
			PktArray[PktIndex++] = Adapter->pNdisPacket[CurrentDescriptorIndex];
			IndicatingPacket = TRUE;

		/* 7. Repeat 1 thru 6 for all received packets. */

#else	/* *NOT* NDIS40_MINIPORT */

			Buffer.Next = NULL;
			Buffer.Size = 0;
			Buffer.MdlFlags = 0;
			Buffer.Process = 0;
			Buffer.MappedSystemVa = PacketVa;
			Buffer.StartVa = PacketVa;
			Buffer.ByteCount = PacketSize;
			Buffer.ByteOffset = 0;

			NdisFlushBuffer (&Buffer, FALSE);

			NdisMUpdateSharedMemory (Adapter->LanceMiniportHandle,
									PacketSize,
									PacketVa,
									Adapter->ReceiveBufferPointerPhysical +
									(CurrentDescriptorIndex	* RECEIVE_BUFFER_SIZE)
									);

			/* Indicate a packet is received and available	*/

			if (PacketSize < MAC_HEADER_SIZE)
			{

				/* Must have at least the destination address	*/

				if (PacketSize >= ETH_LENGTH_OF_ADDRESS)
				{
					/* Runt packet	*/
					NdisMEthIndicateReceive(
						Adapter->LanceMiniportHandle,
						(NDIS_HANDLE)((PUCHAR)PacketVa + MAC_HEADER_SIZE),	// context
						PacketVa,				// header buffer
						PacketSize,			// header buffer size
						NULL,					// lookahead buffer
						0,						// lookahead buffer size
						0						// Packet size not include header
						);
					IndicatingPacket = TRUE;
				}
			}
			else
			{
				NdisMEthIndicateReceive(
					Adapter->LanceMiniportHandle,
					(NDIS_HANDLE)((PUCHAR)PacketVa + MAC_HEADER_SIZE),	// context
					PacketVa,				// header buffer
					MAC_HEADER_SIZE,						// header buffer size
					(PUCHAR)PacketVa + MAC_HEADER_SIZE,	// lookahead buffer
					LookAheadSize - MAC_HEADER_SIZE,		// lookahead buffer size
					PacketSize - MAC_HEADER_SIZE			// packet size
					);

				IndicatingPacket = TRUE;
			}
#endif	/* NDIS40_MINIPORT */

SkipIndication:

			#if DBG
				if(LanceRxDbg && IndicatingPacket)
					DbgPrint("LanceReceiveInterrupt: One rx'd packet reported to system.\n");
			#endif
	
			BufferSize = 1536;
			/*	Restore the bcnt field, it is overwritten by HILANCE!	*/
			*CurrBufferSize = -BufferSize;

			/* Reset the Runt/.. Counts.	*/
			*CurrRMDReserved1 = 0;
/*
	MJ modified to check Multi-Rx
*/
#ifndef NDIS40_MINIPORT
			*CurrRMDFlags = OWN;
#endif

			Adapter->LinkActive = TRUE;

			/* Advance our pointers to the next descriptor.	*/
			if ((++Adapter->NextReceiveDescriptorIndex) >= RECEIVE_BUFFERS)
			{
				Adapter->NextReceiveDescriptorIndex = 0;
			}

			/* Update statistics now based on the receive status.	*/
			if (ReceiveStatus & DERR)
			{

				++Adapter->GeneralMandatory[GM_RECEIVE_BAD];

				if (ReceiveStatus & LANCE_RECEIVE_CRC_ERROR)
				{
					++Adapter->GeneralOptional[GO_RECEIVE_CRC-GO_ARRAY_START];
				}
				else if (ReceiveStatus & LANCE_RECEIVE_FRAME_ERROR)
				{
					++Adapter->MediaMandatory[MM_RECEIVE_ERROR_ALIGNMENT];
				}
				else if (ReceiveStatus & LANCE_RECEIVE_BUFFER_ERROR)
				{
					++Adapter->MediaOptional[MO_RECEIVE_OVERRUN];
				}
			}
			else
			{
				++Adapter->GeneralMandatory[GM_RECEIVE_GOOD];

				if (ReceivePacketType == LANCE_BROADCAST)
				{
					++Adapter->GeneralOptionalFrameCount[GO_BROADCAST_RECEIVES];

					LanceAddUlongToLargeInteger(
							&Adapter->GeneralOptionalByteCount[GO_BROADCAST_RECEIVES],
								PacketSize);

				}
				else if (ReceivePacketType == LANCE_MULTICAST)
				{
					++Adapter->GeneralOptionalFrameCount[GO_MULTICAST_RECEIVES];
					LanceAddUlongToLargeInteger(
							&Adapter->GeneralOptionalByteCount[GO_MULTICAST_RECEIVES],
								PacketSize);

				}
				else
				{

					++Adapter->GeneralOptionalFrameCount[GO_DIRECTED_RECEIVES];
					LanceAddUlongToLargeInteger(
							&Adapter->GeneralOptionalByteCount[GO_DIRECTED_RECEIVES],
								PacketSize);
				}
			} /* END if (ReceiveStatus & DERR) */
		} /* END while (TRUE) */
/*
	MJ modified to check Multi_Rx
*/
#ifdef NDIS40_MINIPORT
		if (IndicatingPacket)
		{
			/* 8. Call NdisMIndicateReceivePacket() with a pointer to the packet array */
			NdisMIndicateReceivePacket(Adapter->LanceMiniportHandle, PktArray, PktIndex);
			RcvComplete (PktArray, BufArray, PktIndex);
			IndicateRxComplete = TRUE;
		}

		if (IndicateRxComplete)
		{
			if (Adapter->CableDisconnected == TRUE)
			{
				Adapter->CableDisconnected = FALSE;
				NdisMIndicateStatus (Adapter->LanceMiniportHandle,
									NDIS_STATUS_MEDIA_CONNECT,
									NULL,
									0
									);
				#if DBG
					if (LanceDbg)
					DbgPrint("Cable Connect reported.\n");
				#endif
			}

//			NdisMEthIndicateReceiveComplete(Adapter->LanceMiniportHandle);
		}

#else	/* *NOT* NDIS40_MINIPORT */

		/* For receiving packet, tell upper layer the job done	*/
		if (IndicatingPacket)
		{
			NdisMEthIndicateReceiveComplete(Adapter->LanceMiniportHandle);
		}
#endif	/* NDIS40_MINIPORT */
	}	/* END if (...) [Check for receive interrupts.]	*/

/****************************************************************************
* Process any transmit interrupts.											*
*****************************************************************************/

	if (Csr0Value & LANCE_CSR0_TINT)
	{
#ifdef NDIS40_MINIPORT

		/* Update stats for all completed transmit descriptors. */
		XmitComplete (Adapter);

#else /* *NOT* NDIS40_MINIPORT */

/* According to the NDIS 4.0 spec, this call is not used or necessary */
/* when the send routine returns NDIS_STATUS_SUCCESS, which it does in all cases */
/* "Conditionalized" the following line 07-30-97 M. Steiger */

		NdisMSendResourcesAvailable(Adapter->LanceMiniportHandle);

#endif /* NDIS40_MINIPORT */

		/* Clear no-reset flag	*/
		Adapter->OpFlags &= ~RESET_PROHIBITED;
	}
	
	/* Check for errors	*/
	if (Csr0Value & LANCE_CSR0_ERR)
	{		
		++Adapter->DmiSpecific[DMI_CSR0_ERR];		
		
		/* Clear interrupt source #1 */
		LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0,
			(LANCE_CSR0_MERR | LANCE_CSR0_BABL | LANCE_CSR0_CERR | LANCE_CSR0_MISS));
		#if DBG
		if (LanceDbg)
		{
			DbgPrint("LanceHandleInterrupt: Error. CSR0 value: %x\n", Csr0Value);
		}
		#endif

		/* Check for different errors and take appropriate steps	*/
		/* to recover from it and update the statastics	*/
		if (Csr0Value & LANCE_CSR0_BABL)
		{
			++Adapter->DmiSpecific[DMI_CSR0_BABL];
			/* Fatal error!	Transmit time-out	*/
			LOG(BABL)
		}

		if (Csr0Value & LANCE_CSR0_MERR)
		{
			++Adapter->DmiSpecific[DMI_CSR0_MERR];
			/* Fatal error! No DACK assert for bus master DMA	*/
			LOG(ERR)
		}

		/* Collision error	*/
		if (Csr0Value & LANCE_CSR0_CERR)
		{
			++Adapter->MediaOptional[MO_TRANSMIT_HEARTBEAT_FAILURE];
			LOG(HEART)
		}

		/* Receive descriptor is not available for coming frame	*/
		if (Csr0Value & LANCE_CSR0_MISS)
		{
			++Adapter->GeneralMandatory[GM_RECEIVE_NO_BUFFER];
			LOG(MISSED)
		}
	}

	/* Finally check if the chip is functioning.	Note: run-time	*/
	/* errors such as UNDERFLOW ERROR or BUFFER ERROR can turn	*/
	/* off the transmitter	*/

	switch (Adapter->DeviceType)
	{
		case PCNET_PCI3:
		case PCNET_PCI2_B2:
		case PCNET_ISA_PLUS_PLUS:
			break;

		case LANCE:
		case PCNET_ISA:
		case PCNET_ISA_PLUS:
		case PCNET_PCI1:
		case PCNET_PCI2_A4:

			if ((Csr0Value & LANCE_CSR0_RUNNING) != LANCE_CSR0_RUNNING)
			{
				#if DBG
				if (LanceDbg)
				{
					DbgPrint("LanceHandleInterrupt: Chip stopped. CSR0 = %x\n", Csr0Value);
				}
				#endif

				/* Restart chip	*/
				Adapter->OpFlags |= STOP_SET;
				LanceInit(Adapter,FALSE);
//				Adapter->OpFlags |= RESET_IN_PROGRESS;

//				if(Adapter->OpFlags & IN_LINK_TIMER)
//				{
//					NdisStallExecution(1);
//				}

//				LanceStopChip(Adapter);
//				LanceSetupRegistersAndInit(Adapter,FALSE);

				/* Start Lance, but do not enable interrupts as	*/
				/* interrupts will be enabled at the end of the DPC. */
//				LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, LANCE_CSR0_START);

				/* Clear the flags and return	*/
//				Adapter->OpFlags &= ~RESET_IN_PROGRESS;
				Adapter->OpFlags &= ~STOP_SET;
			}
			break;

		default:
			break;
 	}

	/* Clean interrupt flag	*/
	Adapter->OpFlags &= ~IN_INTERRUPT_DPC;

	LOG(OUT_DPC)

	#if DBG
		if (LanceDbg)
		DbgPrint("<==LanceHandleInterrupt\n");
	#endif
}

#ifdef	NDIS40_MINIPORT
STATIC
VOID
XmitComplete (
	IN PLANCE_ADAPTER Adapter
	)

{
USHORT	dbgCount=0;

#if 0
	PLANCE_TRANSMIT_DESCRIPTOR		TailDescriptor;
	PLANCE_TRANSMIT_DESCRIPTOR_HI	TailDescriptorHi;
	USHORT							TailDescriptorIndex;
	BOOLEAN							IsCancelled;
	USHORT							TransmitStatus;
	USHORT							TransmitError;
	ULONG							Data;
	
#if DBG	
	if (LanceDbg)
		DbgPrint("==>XmitComplete : %i\n",Adapter->RedundantMode);
#endif

	while (Adapter->TailTransmitDescriptorIndex != Adapter->NextTransmitDescriptorIndex)
	{
#if DBG
	dbgCount++;
	if (LanceDbg)
		DbgPrint("One tx packet completion processed.\n");
#endif

		TailDescriptorIndex = Adapter->TailTransmitDescriptorIndex;

		/*	Get info from the last transmit descriptor: */
			/* transmit status */
			/* transmit error */
		if (Adapter->SwStyle == SW_STYLE_2)
		{
			TailDescriptorHi	= (PLANCE_TRANSMIT_DESCRIPTOR_HI)Adapter->TransmitDescriptorRing + TailDescriptorIndex;
			TransmitStatus 		= TailDescriptorHi->LanceTMDFlags;
			TransmitError		= TailDescriptorHi->TransmitError;
		}
		else
		{
			TailDescriptor		= (PLANCE_TRANSMIT_DESCRIPTOR)Adapter->TransmitDescriptorRing + TailDescriptorIndex;
			TransmitStatus		= TailDescriptor->LanceTMDFlags;
			TransmitError		= TailDescriptor->TransmitError;
		}

		if (TransmitStatus & LANCE_TRANSMIT_BUF_ERROR)
			++Adapter->DmiSpecific[DMI_TXBUFF_ERR];

		if (TransmitStatus & LANCE_TRANSMIT_EXDEF_ERROR)
			++Adapter->DmiSpecific[DMI_EX_DEFER];

		if (TransmitStatus & OWN)
			break;

//		Adapter->TxBufsUsed--;

#if DBG
	dbgCount++;
#endif

		if (++Adapter->TailTransmitDescriptorIndex >= TRANSMIT_BUFFERS)
		{
			Adapter->TailTransmitDescriptorIndex = 0;
		}
// move to send
		/* Update statistics for transmitted packets, the oldest one first.	*/
		if (TransmitStatus & (DERR | LANCE_TRANSMIT_DEF_ERROR))
		{
			/* Update general error statistics	*/
			++Adapter->GeneralMandatory[GM_TRANSMIT_BAD];

			if (TransmitStatus & LANCE_TRANSMIT_DEF_ERROR)
			{
				++Adapter->MediaOptional[MO_TRANSMIT_DEFERRED];
			}

			if (TransmitStatus & DERR)
			{
				if (TransmitError & LANCE_TRANSMIT_UFLO_ERROR)
				{
					++Adapter->MediaOptional[MO_TRANSMIT_UNDERRUN];
				}

				#if DBG
				if (LanceDbg||LanceSendDbg)
					DbgPrint("Transmit: UFLO error detected\n");
				#endif
			}

			if (TransmitError & LANCE_TRANSMIT_LCAR_ERROR)
			{
#ifdef NDIS40_MINIPORT

#ifdef _FAILOVER
	if ((ActiveAdapter == PRI)&&(Adapter->RedundantMode == 1))
	{
		goto DoNotIndicateCableDisconnect;
	}
#endif
				if (!Adapter->CableDisconnected)
				{
					Adapter->CableDisconnected = TRUE;
					NdisMIndicateStatus (Adapter->LanceMiniportHandle,
										NDIS_STATUS_MEDIA_DISCONNECT,
										NULL,
										0
										);
				}

DoNotIndicateCableDisconnect:

				++Adapter->MediaOptional[MO_TRANSMIT_TIMES_CRS_LOST];

				#if DBG
				if (LanceDbg||LanceSendDbg)
					DbgPrint("Transmit: Loss of carrier detected.\n");
				#endif
				#endif
			}

			if (TransmitError & LANCE_TRANSMIT_LCOL_ERROR)
			{
				++Adapter->MediaOptional[MO_TRANSMIT_LATE_COLLISIONS];
			}

			if (TransmitError & LANCE_TRANSMIT_RTRY_ERROR)
			{
				++Adapter->MediaOptional[MO_TRANSMIT_MAX_COLLISIONS];
			}

			if (TransmitError & LANCE_TRANSMIT_BUF_ERROR)
			{
				#if DBG
				if (LanceDbg||LanceSendDbg)
					DbgPrint("Transmit: Buffer error detected.\n");
				#endif
			}
		}
		else
		{

			Adapter->LinkActive = TRUE;

			/* Update general good statistics	*/
			++Adapter->GeneralMandatory[GM_TRANSMIT_GOOD];

			if (TransmitStatus & LANCE_TRANSMIT_ONE_COLLISION)
			{
				++Adapter->MediaMandatory[MM_TRANSMIT_ONE_COLLISION];
			}

			if	(TransmitStatus & LANCE_TRANSMIT_MORE_COLLISION)
			{
				++Adapter->MediaMandatory[MM_TRANSMIT_MORE_COLLISIONS];
			}

			Adapter->DmiSpecific[DMI_TX_BYTES] += (COUNTER64) Adapter->TransmitPacketLength[TailDescriptorIndex];

			/* Get saved packet information for this descriptor	*/
			switch (Adapter->TransmitPacketType[TailDescriptorIndex])
			{

				case LANCE_DIRECTED:
					++Adapter->GeneralOptionalFrameCount[GO_DIRECTED_TRANSMITS];
					LanceAddUlongToLargeInteger(
					&Adapter->GeneralOptionalByteCount[GO_DIRECTED_TRANSMITS],
					Adapter->TransmitPacketLength[TailDescriptorIndex]);
					break;

				case LANCE_MULTICAST:
					++Adapter->GeneralOptionalFrameCount[GO_MULTICAST_TRANSMITS];
					LanceAddUlongToLargeInteger(
					&Adapter->GeneralOptionalByteCount[GO_MULTICAST_TRANSMITS],
					Adapter->TransmitPacketLength[TailDescriptorIndex]);
					break;

				case LANCE_BROADCAST:
					++Adapter->GeneralOptionalFrameCount[GO_BROADCAST_TRANSMITS];
					LanceAddUlongToLargeInteger(
					&Adapter->GeneralOptionalByteCount[GO_BROADCAST_TRANSMITS],
					Adapter->TransmitPacketLength[TailDescriptorIndex]);

			}	/* switch */

		}	/* if...else */

	}	/* while */
	#if DBG
		if (LanceSendDbg)
			DbgPrint("In Interrupt. Pkts sent : %i\n", dbgCount);
	#endif 
#endif /* #if 0 */

	/* Disable TX interrupts here */
// MJ : Disabled tx watermark
//	LANCE_READ_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR3, &Data);
//	Data |= LANCE_CSR3_TINTM;
//	LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR3, Data);

//MJ modified | to &
	if (Adapter->OpFlags & TX_RESOURCES)
	{
		Adapter->OpFlags &= ~TX_RESOURCES;
		NdisMSendResourcesAvailable(Adapter->LanceMiniportHandle);
#if DBG
	if (LanceSendDbg)
		DbgPrint("In Interrupt. ResourceAvailable\n");
#endif
	}

	/* Clear interrupt source #3 */
	LANCE_WRITE_CSR(Adapter->MappedIoBaseAddress, LANCE_CSR0, LANCE_CSR0_TINT);

#if DBG
	if (LanceSendDbg)
		DbgPrint("In Interrupt. Pkts sent : %i\n",dbgCount);
#endif
#if DBG
	if (LanceDbg)
		DbgPrint("<==XmitComplete\n");
#endif
}	/* End of function XmitComplete () */

STATIC
VOID
RcvComplete (
	PNDIS_PACKET			*PktArray,
	PNDIS_BUFFER			*BufArray,
	USHORT					PktIndex
	)
{
	USHORT					TempIndex;
	PNDIS_PACKET_OOB_DATA			OobyDoobyData;

	/* Adjust buffer lengths and dis-own each descriptor in FIFO order	*/
	/* whilst unwinding the index 	*/
	TempIndex = 0;	/* Start the index at 0 so the oldest is freed first */
	while (PktIndex--) /* Count the packet index down to 0 */
	{
		/* 9. Check each packet's status using NDIS_GET_PACKET_STATUS and ensure		*/
		/*    that status is equal to NDIS_STATUS_SUCCESS */
		if (NDIS_GET_PACKET_STATUS(PktArray[TempIndex]) != NDIS_STATUS_PENDING)
		{
			OobyDoobyData = NDIS_OOB_DATA_FROM_PACKET (PktArray[TempIndex]);
			NdisZeroMemory (OobyDoobyData, sizeof(PNDIS_PACKET_OOB_DATA));
			OobyDoobyData->HeaderSize = 14;
			OobyDoobyData->SizeMediaSpecificInfo = 0;
			OobyDoobyData->MediaSpecificInformation = NULL;

			/* 10. Restore each used buffer's size by calling NdisAdjustBufferLength () */
			NdisAdjustBufferLength(BufArray[TempIndex], RECEIVE_BUFFER_SIZE);
		}
		else	/* This should never happen. */
		{
			#if DBG
			if(LanceRxDbg)
			{
				DbgPrint("Packet number %i has been pended\n",TempIndex);
			}
			#endif
		}
		/* Using the address of CurrRMDFlags saved in the MiniportReserved field,	*/
		/* Set the ownership bit so that the descriptor belongs to LANCE			*/
		**((UCHAR **)&(PktArray[TempIndex]->MiniportReserved[0])) = OWN;
		TempIndex++; /* Increment the index */

	}
}

VOID
LanceReturnPacket(
	IN	NDIS_HANDLE	MiniportAdapterContext,
	IN PNDIS_PACKET Packet
	)
{
	UINT phyCnt,bufCnt,length;
	PNDIS_BUFFER pBuffer=NULL;
	PNDIS_PACKET_OOB_DATA OobyDoobyData;
	PLANCE_ADAPTER Adapter = (PLANCE_ADAPTER)MiniportAdapterContext;

	#if DBG
	if(LanceRxDbg)
	{
		DbgPrint("==> LanceReturnPacket\n");
	}
	#endif

	if (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_SUCCESS)
	{
		OobyDoobyData = NDIS_OOB_DATA_FROM_PACKET (Packet);
		NdisZeroMemory (OobyDoobyData, sizeof(PNDIS_PACKET_OOB_DATA));
		OobyDoobyData->HeaderSize = 14;
		OobyDoobyData->SizeMediaSpecificInfo = 0;
		OobyDoobyData->MediaSpecificInformation = NULL;

		/* 10. Restore each used buffer's size by calling NdisAdjustBufferLength () */
		NdisQueryPacket(Packet,&phyCnt,&bufCnt,&pBuffer,&length);
		NdisAdjustBufferLength(pBuffer, RECEIVE_BUFFER_SIZE);
	}
	else
	{
		#if DBG
			if(LanceRxDbg)
			{
				DbgPrint("Packet Status is not SUCCESS, which should never happen\n");
				DbgBreakPoint();
			}
		#endif

	}
	/* Using the address of CurrRMDFlags saved in the MiniportReserved field,	*/
	/* Set the ownership bit so that the descriptor belongs to LANCE			*/
	**((UCHAR **)&(Packet->MiniportReserved[0])) = OWN;

	#if DBG
	if(LanceRxDbg)
	{
		DbgPrint("<== LanceReturnPacket\n");
	}
	#endif
}

#endif	/* NDIS40_MINIPORT */
